 1. Код для подсчёта гласных в строке

#### C++
```cpp
#include <iostream>
#include <string>
using namespace std;

int countVowels(const string& str, int index = 0) {
    // Базовый случай: достигли конца строки
    if (index >= str.length()) {
        return 0;
    }
    
    char ch = tolower(str[index]);
    int current = 0;
    
    // Проверяем, является ли текущий символ гласной
    if (ch == 'a' || ch == 'e' || ch == 'i' || 
        ch == 'o' || ch == 'u') {
        current = 1;
    }
    
    // Рекурсивный вызов для оставшейся части строки
    return current + countVowels(str, index + 1);
}

int main() {
    string input;
    cout << "Введите строку: ";
    getline(cin, input);
    
    int result = countVowels(input);
    cout << "Количество гласных: " << result << endl;
    
    return 0;
}
```

**Объяснение алгоритма (C++):**  
1. Функция `countVowels` принимает строку и текущий индекс (по умолчанию — 0).  
2. **Базовый случай:** если индекс вышел за границы строки, возвращаем 0 (больше символов нет).  
3. Преобразуем текущий символ в нижний регистр для унификации проверки.  
4. Если символ — гласная (`a`, `e`, `i`, `o`, `u`), считаем его (прибавляем 1).  
5. Рекурсивно вызываем функцию для следующего индекса и прибавляем результат к текущему счёту.  
6. Итог: сумма всех гласных от текущего индекса до конца строки.

**Временная сложность:**  
- **O(n)**, где *n* — длина строки.  
- Каждый символ обрабатывается ровно один раз (один рекурсивный вызов на символ).  
- Глубина рекурсии тоже *n*, но это не влияет на асимптотику.

#### Java
```java
import java.util.Scanner;

public class VowelCounter {
    public static int countVowels(String str, int index) {
        if (index >= str.length()) {
            return 0;
        }
        
        char ch = Character.toLowerCase(str.charAt(index));
        int current = (ch == 'a' || ch == 'e' || ch == 'i' || 
                      ch == 'o' || ch == 'u') ? 1 : 0;
        
        return current + countVowels(str, index + 1);
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите строку: ");
        String input = scanner.nextLine();
        
        int result = countVowels(input, 0);
        System.out.println("Количество гласных: " + result);
        
        scanner.close();
    }
}
```

#### Python
```python
def count_vowels(s, index=0):
    if index >= len(s):
        return 0
    
    ch = s[index].lower()
    current = 1 if ch in 'aeiou' else 0
    
    return current + count_vowels(s, index + 1)

# Пример использования
input_str = input("Введите строку: ")
result = count_vowels(input_str)
print("Количество гласных:", result)
```

---

### 2. Стратегия «разделяй и властвуй» на примере сортировки слиянием

**Суть стратегии:**  
Задача разбивается на более мелкие подзадачи того же типа, решается рекурсивно, а затем результаты объединяются в общее решение.

**Сортировка слиянием (Merge Sort):**  
1. **Разделение:** Массив делится пополам до подмассивов размером 1 (они уже отсортированы).  
2. **Решение:** Рекурсивно сортируем каждую половину.  
3. **Объединение:** Сливаем две отсортированные половины в один упорядоченный массив.

**Пример:**  
Массив `[3, 7, 1, 5]` →  
- Делим: `[3, 7]` и `[1, 5]` →  
- Делим дальше: `[3]`, `[7]`, `[1]`, `[5]` →  
- Сливаем: `[3, 7]` и `[1, 5]` →  
- Сливаем окончательно: `[1, 3, 5, 7]`.

**Почему это «разделяй и властвуй»:**  
- Задача сортировки большого массива сводится к сортировке меньших массивов.  
- Решение строится из решений подзадач (слияние).  
- Рекурсия обеспечивает автоматическое разбиение до тривиальных случаев.

**Временная сложность:** O(n log n) — оптимально для сравнительных сортировок.