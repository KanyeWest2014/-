 1. Код для подсчёта гласных в строке

**Объяснение алгоритма (C++):**  
1. Функция `countVowels` принимает строку и текущий индекс (по умолчанию — 0).  
2. **Базовый случай:** если индекс вышел за границы строки, возвращаем 0 (больше символов нет).  
3. Преобразуем текущий символ в нижний регистр для унификации проверки.  
4. Если символ — гласная (`a`, `e`, `i`, `o`, `u`), считаем его (прибавляем 1).  
5. Рекурсивно вызываем функцию для следующего индекса и прибавляем результат к текущему счёту.  
6. Итог: сумма всех гласных от текущего индекса до конца строки.

**Временная сложность:**  
- **O(n)**, где *n* — длина строки.  
- Каждый символ обрабатывается ровно один раз (один рекурсивный вызов на символ).  
- Глубина рекурсии тоже *n*, но это не влияет на асимптотику.


КОНТРОЛЬНЫЙ ВОПРОС (№5)
"Стратегия «разделяй и властвуй» на примере сортировки слиянием"

**Суть стратегии:**  
Задача разбивается на более мелкие подзадачи того же типа, решается рекурсивно, а затем результаты объединяются в общее решение.

**Сортировка слиянием (Merge Sort):**  
1. **Разделение:** Массив делится пополам до подмассивов размером 1 (они уже отсортированы).  
2. **Решение:** Рекурсивно сортируем каждую половину.  
3. **Объединение:** Сливаем две отсортированные половины в один упорядоченный массив.

**Пример:**  
Массив `[3, 7, 1, 5]` →  
- Делим: `[3, 7]` и `[1, 5]` →  
- Делим дальше: `[3]`, `[7]`, `[1]`, `[5]` →  
- Сливаем: `[3, 7]` и `[1, 5]` →  
- Сливаем окончательно: `[1, 3, 5, 7]`.

**Почему это «разделяй и властвуй»:**  
- Задача сортировки большого массива сводится к сортировке меньших массивов.  
- Решение строится из решений подзадач (слияние).  
- Рекурсия обеспечивает автоматическое разбиение до тривиальных случаев.

